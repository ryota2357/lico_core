//! This file is generated by `cargo codegen syntax`, do not edit by hand.
#![cfg_attr(rustfmt, rustfmt::skip)]

use super::{LicoLanguage, SyntaxKind, SyntaxNode, SyntaxToken};
use core::fmt;
use rowan::ast::support;
pub use rowan::ast::{AstChildren, AstNode};

pub struct SourceFile(SyntaxNode);
impl AstNode for SourceFile {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::SOURCE_FILE
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl SourceFile {
    pub fn shebang(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::SHEBANG)
    }
    pub fn stmt(&self) -> AstChildren<Stmt> { support::children(AstNode::syntax(self)) }
}
impl fmt::Display for SourceFile {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub enum Stmt {
    Attr(AttrStmt),
    Break(BreakStmt),
    Continue(ContinueStmt),
    For(ForStmt),
    Func(FuncStmt),
    Return(ReturnStmt),
    Var(VarStmt),
    While(WhileStmt),
    Expr(Expr),
}
impl AstNode for Stmt {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        <AttrStmt as AstNode>::can_cast(kind)
            || <BreakStmt as AstNode>::can_cast(kind)
            || <ContinueStmt as AstNode>::can_cast(kind)
            || <ForStmt as AstNode>::can_cast(kind)
            || <FuncStmt as AstNode>::can_cast(kind)
            || <ReturnStmt as AstNode>::can_cast(kind)
            || <VarStmt as AstNode>::can_cast(kind)
            || <WhileStmt as AstNode>::can_cast(kind)
            || <Expr as AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        let kind = node.kind();
        if <AttrStmt as AstNode>::can_cast(kind) {
            let casted =
                <AttrStmt as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Attr(casted));
        }
        if <BreakStmt as AstNode>::can_cast(kind) {
            let casted =
                <BreakStmt as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Break(casted));
        }
        if <ContinueStmt as AstNode>::can_cast(kind) {
            let casted =
                <ContinueStmt as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Continue(casted));
        }
        if <ForStmt as AstNode>::can_cast(kind) {
            let casted =
                <ForStmt as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::For(casted));
        }
        if <FuncStmt as AstNode>::can_cast(kind) {
            let casted =
                <FuncStmt as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Func(casted));
        }
        if <ReturnStmt as AstNode>::can_cast(kind) {
            let casted =
                <ReturnStmt as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Return(casted));
        }
        if <VarStmt as AstNode>::can_cast(kind) {
            let casted =
                <VarStmt as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Var(casted));
        }
        if <WhileStmt as AstNode>::can_cast(kind) {
            let casted =
                <WhileStmt as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::While(casted));
        }
        if <Expr as AstNode>::can_cast(kind) {
            let casted = <Expr as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Expr(casted));
        }
        None
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
        match self {
            Self::Attr(x) => x.syntax(),
            Self::Break(x) => x.syntax(),
            Self::Continue(x) => x.syntax(),
            Self::For(x) => x.syntax(),
            Self::Func(x) => x.syntax(),
            Self::Return(x) => x.syntax(),
            Self::Var(x) => x.syntax(),
            Self::While(x) => x.syntax(),
            Self::Expr(x) => x.syntax(),
        }
    }
}
impl fmt::Display for Stmt {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct AttrStmt(SyntaxNode);
impl AstNode for AttrStmt {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::ATTR_STMT
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl AttrStmt {
    pub fn at_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::AT)
    }
    pub fn bang_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::BANG)
    }
    pub fn open_bracket_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::OPEN_BRACKET)
    }
    pub fn command(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::IDENT)
    }
    pub fn close_bracket_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::CLOSE_BRACKET)
    }
}
impl fmt::Display for AttrStmt {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct BreakStmt(SyntaxNode);
impl AstNode for BreakStmt {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::BREAK_STMT
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl BreakStmt {
    pub fn break_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::BREAK_KW)
    }
}
impl fmt::Display for BreakStmt {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct ContinueStmt(SyntaxNode);
impl AstNode for ContinueStmt {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::CONTINUE_STMT
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl ContinueStmt {
    pub fn continue_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::CONTINUE_KW)
    }
}
impl fmt::Display for ContinueStmt {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct ForStmt(SyntaxNode);
impl AstNode for ForStmt {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::FOR_STMT
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl ForStmt {
    pub fn for_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::FOR_KW)
    }
    pub fn pat(&self) -> Option<Pat> { support::child(AstNode::syntax(self)) }
    pub fn in_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::IN_KW)
    }
    pub fn iterable(&self) -> Option<Expr> { support::child(AstNode::syntax(self)) }
    pub fn loop_body(&self) -> Option<DoExpr> { support::child(AstNode::syntax(self)) }
}
impl fmt::Display for ForStmt {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct FuncStmt(SyntaxNode);
impl AstNode for FuncStmt {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::FUNC_STMT
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl FuncStmt {
    pub fn func_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::FUNC_KW)
    }
    pub fn name(&self) -> Option<Name> { support::child(AstNode::syntax(self)) }
    pub fn param_list(&self) -> Option<ParamList> { support::child(AstNode::syntax(self)) }
    pub fn statements(&self) -> AstChildren<Stmt> { support::children(AstNode::syntax(self)) }
    pub fn end_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::END_KW)
    }
}
impl fmt::Display for FuncStmt {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct ReturnStmt(SyntaxNode);
impl AstNode for ReturnStmt {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::RETURN_STMT
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl ReturnStmt {
    pub fn return_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::RETURN_KW)
    }
    pub fn expr(&self) -> Option<Expr> { support::child(AstNode::syntax(self)) }
}
impl fmt::Display for ReturnStmt {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct VarStmt(SyntaxNode);
impl AstNode for VarStmt {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::VAR_STMT
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl VarStmt {
    pub fn var_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::VAR_KW)
    }
    pub fn pat(&self) -> Option<Pat> { support::child(AstNode::syntax(self)) }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::EQ)
    }
    pub fn expr(&self) -> Option<Expr> { support::child(AstNode::syntax(self)) }
}
impl fmt::Display for VarStmt {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct WhileStmt(SyntaxNode);
impl AstNode for WhileStmt {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::WHILE_STMT
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl WhileStmt {
    pub fn while_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::WHILE_KW)
    }
    pub fn condition(&self) -> Option<Expr> { support::child(AstNode::syntax(self)) }
    pub fn loop_body(&self) -> Option<DoExpr> { support::child(AstNode::syntax(self)) }
}
impl fmt::Display for WhileStmt {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub enum Expr {
    Array(ArrayExpr),
    Binary(BinaryExpr),
    Call(CallExpr),
    Do(DoExpr),
    Field(FieldExpr),
    Func(FuncExpr),
    If(IfExpr),
    Index(IndexExpr),
    Literal(Literal),
    Local(Local),
    MethodCall(MethodCallExpr),
    Paren(ParenExpr),
    Prefix(PrefixExpr),
    Table(TableExpr),
}
impl AstNode for Expr {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        <ArrayExpr as AstNode>::can_cast(kind)
            || <BinaryExpr as AstNode>::can_cast(kind)
            || <CallExpr as AstNode>::can_cast(kind)
            || <DoExpr as AstNode>::can_cast(kind)
            || <FieldExpr as AstNode>::can_cast(kind)
            || <FuncExpr as AstNode>::can_cast(kind)
            || <IfExpr as AstNode>::can_cast(kind)
            || <IndexExpr as AstNode>::can_cast(kind)
            || <Literal as AstNode>::can_cast(kind)
            || <Local as AstNode>::can_cast(kind)
            || <MethodCallExpr as AstNode>::can_cast(kind)
            || <ParenExpr as AstNode>::can_cast(kind)
            || <PrefixExpr as AstNode>::can_cast(kind)
            || <TableExpr as AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        let kind = node.kind();
        if <ArrayExpr as AstNode>::can_cast(kind) {
            let casted =
                <ArrayExpr as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Array(casted));
        }
        if <BinaryExpr as AstNode>::can_cast(kind) {
            let casted =
                <BinaryExpr as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Binary(casted));
        }
        if <CallExpr as AstNode>::can_cast(kind) {
            let casted =
                <CallExpr as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Call(casted));
        }
        if <DoExpr as AstNode>::can_cast(kind) {
            let casted =
                <DoExpr as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Do(casted));
        }
        if <FieldExpr as AstNode>::can_cast(kind) {
            let casted =
                <FieldExpr as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Field(casted));
        }
        if <FuncExpr as AstNode>::can_cast(kind) {
            let casted =
                <FuncExpr as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Func(casted));
        }
        if <IfExpr as AstNode>::can_cast(kind) {
            let casted =
                <IfExpr as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::If(casted));
        }
        if <IndexExpr as AstNode>::can_cast(kind) {
            let casted =
                <IndexExpr as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Index(casted));
        }
        if <Literal as AstNode>::can_cast(kind) {
            let casted =
                <Literal as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Literal(casted));
        }
        if <Local as AstNode>::can_cast(kind) {
            let casted = <Local as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Local(casted));
        }
        if <MethodCallExpr as AstNode>::can_cast(kind) {
            let casted =
                <MethodCallExpr as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::MethodCall(casted));
        }
        if <ParenExpr as AstNode>::can_cast(kind) {
            let casted =
                <ParenExpr as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Paren(casted));
        }
        if <PrefixExpr as AstNode>::can_cast(kind) {
            let casted =
                <PrefixExpr as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Prefix(casted));
        }
        if <TableExpr as AstNode>::can_cast(kind) {
            let casted =
                <TableExpr as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Table(casted));
        }
        None
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
        match self {
            Self::Array(x) => x.syntax(),
            Self::Binary(x) => x.syntax(),
            Self::Call(x) => x.syntax(),
            Self::Do(x) => x.syntax(),
            Self::Field(x) => x.syntax(),
            Self::Func(x) => x.syntax(),
            Self::If(x) => x.syntax(),
            Self::Index(x) => x.syntax(),
            Self::Literal(x) => x.syntax(),
            Self::Local(x) => x.syntax(),
            Self::MethodCall(x) => x.syntax(),
            Self::Paren(x) => x.syntax(),
            Self::Prefix(x) => x.syntax(),
            Self::Table(x) => x.syntax(),
        }
    }
}
impl fmt::Display for Expr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub enum Pat {
    Name(Name),
    Wildcard(WildcardPat),
}
impl AstNode for Pat {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        <Name as AstNode>::can_cast(kind) || <WildcardPat as AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        let kind = node.kind();
        if <Name as AstNode>::can_cast(kind) {
            let casted = <Name as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Name(casted));
        }
        if <WildcardPat as AstNode>::can_cast(kind) {
            let casted =
                <WildcardPat as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Wildcard(casted));
        }
        None
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
        match self {
            Self::Name(x) => x.syntax(),
            Self::Wildcard(x) => x.syntax(),
        }
    }
}
impl fmt::Display for Pat {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct DoExpr(SyntaxNode);
impl AstNode for DoExpr {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::DO_EXPR
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl DoExpr {
    pub fn do_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::DO_KW)
    }
    pub fn statements(&self) -> AstChildren<Stmt> { support::children(AstNode::syntax(self)) }
    pub fn end_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::END_KW)
    }
}
impl fmt::Display for DoExpr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct Name(SyntaxNode);
impl AstNode for Name {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::NAME
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl Name {
    pub fn ident(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::IDENT)
    }
}
impl fmt::Display for Name {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct ParamList(SyntaxNode);
impl AstNode for ParamList {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::PARAM_LIST
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl ParamList {
    pub fn open_paren_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::OPEN_PAREN)
    }
    pub fn params(&self) -> Option<Param> { support::child(AstNode::syntax(self)) }
    pub fn close_paren_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::CLOSE_PAREN)
    }
}
impl fmt::Display for ParamList {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct ArrayExpr(SyntaxNode);
impl AstNode for ArrayExpr {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::ARRAY_EXPR
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl ArrayExpr {
    pub fn open_bracket_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::OPEN_BRACKET)
    }
    pub fn expr(&self) -> Option<Expr> { support::child(AstNode::syntax(self)) }
    pub fn close_bracket_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::CLOSE_BRACKET)
    }
}
impl fmt::Display for ArrayExpr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct BinaryExpr(SyntaxNode);
impl AstNode for BinaryExpr {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::BINARY_EXPR
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl BinaryExpr {
    pub fn lhs(&self) -> Option<Expr> { support::child(AstNode::syntax(self)) }
    pub fn op(&self) -> Option<(SyntaxToken, BinaryOp)> {
        self.syntax().children_with_tokens().filter_map(|it| it.into_token()).find_map(|token| {
            let op = match token.kind() {
                SyntaxKind::EQ => BinaryOp::Assign,
                SyntaxKind::AND_KW => BinaryOp::And,
                SyntaxKind::OR_KW => BinaryOp::Or,
                SyntaxKind::EQ_2 => BinaryOp::Eq,
                SyntaxKind::BANG_EQ => BinaryOp::Ne,
                SyntaxKind::LE => BinaryOp::Le,
                SyntaxKind::GE => BinaryOp::Ge,
                SyntaxKind::LT => BinaryOp::Lt,
                SyntaxKind::GT => BinaryOp::Gt,
                SyntaxKind::PLUS => BinaryOp::Add,
                SyntaxKind::STAR => BinaryOp::Mul,
                SyntaxKind::MINUS => BinaryOp::Sub,
                SyntaxKind::SLASH => BinaryOp::Div,
                SyntaxKind::PERCENT => BinaryOp::Mod,
                SyntaxKind::LT_2 => BinaryOp::Shl,
                SyntaxKind::GT_2 => BinaryOp::Shr,
                SyntaxKind::DOT_2 => BinaryOp::Concat,
                SyntaxKind::CARET => BinaryOp::BitXor,
                SyntaxKind::PIPE => BinaryOp::BitOr,
                SyntaxKind::AMP => BinaryOp::BitAnd,
                _ => return None,
            };
            Some((token, op))
        })
    }
    pub fn op_token(&self) -> Option<SyntaxToken> { self.op().map(|(token, _)| token) }
    pub fn op_kind(&self) -> Option<BinaryOp> { self.op().map(|(_, kind)| kind) }
    pub fn rhs(&self) -> Option<Expr> { support::children(AstNode::syntax(self)).nth(1usize) }
}
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum BinaryOp {
    Assign,
    And,
    Or,
    Eq,
    Ne,
    Le,
    Ge,
    Lt,
    Gt,
    Add,
    Mul,
    Sub,
    Div,
    Mod,
    Shl,
    Shr,
    Concat,
    BitXor,
    BitOr,
    BitAnd,
}
impl BinaryOp {
    pub fn sign_text(&self) -> &'static str {
        match self {
            BinaryOp::Assign => "=",
            BinaryOp::And => "and",
            BinaryOp::Or => "or",
            BinaryOp::Eq => "==",
            BinaryOp::Ne => "!=",
            BinaryOp::Le => "<=",
            BinaryOp::Ge => ">=",
            BinaryOp::Lt => "<",
            BinaryOp::Gt => ">",
            BinaryOp::Add => "+",
            BinaryOp::Mul => "*",
            BinaryOp::Sub => "-",
            BinaryOp::Div => "/",
            BinaryOp::Mod => "%",
            BinaryOp::Shl => "<<",
            BinaryOp::Shr => ">>",
            BinaryOp::Concat => "..",
            BinaryOp::BitXor => "^",
            BinaryOp::BitOr => "|",
            BinaryOp::BitAnd => "&",
        }
    }
}
impl fmt::Display for BinaryExpr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct CallExpr(SyntaxNode);
impl AstNode for CallExpr {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::CALL_EXPR
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl CallExpr {
    pub fn expr(&self) -> Option<Expr> { support::child(AstNode::syntax(self)) }
    pub fn arg_list(&self) -> Option<ArgList> { support::child(AstNode::syntax(self)) }
}
impl fmt::Display for CallExpr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct FieldExpr(SyntaxNode);
impl AstNode for FieldExpr {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::FIELD_EXPR
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl FieldExpr {
    pub fn expr(&self) -> Option<Expr> { support::child(AstNode::syntax(self)) }
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::DOT)
    }
    pub fn name(&self) -> Option<Name> { support::child(AstNode::syntax(self)) }
}
impl fmt::Display for FieldExpr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct FuncExpr(SyntaxNode);
impl AstNode for FuncExpr {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::FUNC_EXPR
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl FuncExpr {
    pub fn func_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::FUNC_KW)
    }
    pub fn param_list(&self) -> Option<ParamList> { support::child(AstNode::syntax(self)) }
    pub fn statements(&self) -> AstChildren<Stmt> { support::children(AstNode::syntax(self)) }
    pub fn end_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::END_KW)
    }
}
impl fmt::Display for FuncExpr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct IfExpr(SyntaxNode);
impl AstNode for IfExpr {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::IF_EXPR
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl IfExpr {
    pub fn if_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::IF_KW)
    }
    pub fn condition(&self) -> Option<Expr> { support::child(AstNode::syntax(self)) }
    pub fn then_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::THEN_KW)
    }
    pub fn statements(&self) -> AstChildren<Stmt> { support::children(AstNode::syntax(self)) }
    pub fn elif_branches(&self) -> AstChildren<ElifBranch> {
        support::children(AstNode::syntax(self))
    }
    pub fn else_branche(&self) -> Option<ElseBranch> { support::child(AstNode::syntax(self)) }
    pub fn end_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::END_KW)
    }
}
impl fmt::Display for IfExpr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct IndexExpr(SyntaxNode);
impl AstNode for IndexExpr {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::INDEX_EXPR
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl IndexExpr {
    pub fn expr(&self) -> Option<Expr> { support::child(AstNode::syntax(self)) }
    pub fn open_bracket_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::OPEN_BRACKET)
    }
    pub fn index(&self) -> Option<Expr> { support::children(AstNode::syntax(self)).nth(1usize) }
    pub fn close_bracket_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::CLOSE_BRACKET)
    }
}
impl fmt::Display for IndexExpr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct Literal(SyntaxNode);
impl AstNode for Literal {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::LITERAL
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl Literal {
    pub fn token(&self) -> Option<SyntaxToken> {
        self.syntax()
            .children_with_tokens()
            .filter_map(|it| it.into_token())
            .find(|it| it.kind().is_literal())
    }
    pub fn kind(&self) -> Option<LiteralKind> {
        let token = self.token()?;
        let kind = match token.kind() {
            SyntaxKind::INT => LiteralKind::Int,
            SyntaxKind::FLOAT => LiteralKind::Float,
            SyntaxKind::STRING => LiteralKind::String,
            SyntaxKind::TRUE => LiteralKind::Bool(true),
            SyntaxKind::FALSE => LiteralKind::Bool(false),
            SyntaxKind::NIL => LiteralKind::Nil,
            _ => return None,
        };
        Some(kind)
    }
}
pub enum LiteralKind {
    Int,
    Float,
    String,
    Bool(bool),
    Nil,
}
impl fmt::Display for Literal {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct Local(SyntaxNode);
impl AstNode for Local {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::LOCAL
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl Local {
    pub fn name(&self) -> Option<Name> { support::child(AstNode::syntax(self)) }
}
impl fmt::Display for Local {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct MethodCallExpr(SyntaxNode);
impl AstNode for MethodCallExpr {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::METHOD_CALL_EXPR
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl MethodCallExpr {
    pub fn expr(&self) -> Option<Expr> { support::child(AstNode::syntax(self)) }
    pub fn arrow_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::ARROW)
    }
    pub fn ident(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::IDENT)
    }
    pub fn arg_list(&self) -> Option<ArgList> { support::child(AstNode::syntax(self)) }
}
impl fmt::Display for MethodCallExpr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct ParenExpr(SyntaxNode);
impl AstNode for ParenExpr {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::PAREN_EXPR
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl ParenExpr {
    pub fn open_paren_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::OPEN_PAREN)
    }
    pub fn expr(&self) -> Option<Expr> { support::child(AstNode::syntax(self)) }
    pub fn close_paren_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::CLOSE_PAREN)
    }
}
impl fmt::Display for ParenExpr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct PrefixExpr(SyntaxNode);
impl AstNode for PrefixExpr {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::PREFIX_EXPR
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl PrefixExpr {
    pub fn op(&self) -> Option<(SyntaxToken, PrefixOp)> {
        self.syntax().children_with_tokens().filter_map(|it| it.into_token()).find_map(|token| {
            let op = match token.kind() {
                SyntaxKind::PLUS => PrefixOp::Plus,
                SyntaxKind::MINUS => PrefixOp::Minus,
                SyntaxKind::TILDE => PrefixOp::BitNot,
                SyntaxKind::NOT_KW => PrefixOp::Not,
                SyntaxKind::TYPEOF_KW => PrefixOp::TypeOf,
                _ => return None,
            };
            Some((token, op))
        })
    }
    pub fn op_token(&self) -> Option<SyntaxToken> { self.op().map(|(token, _)| token) }
    pub fn op_kind(&self) -> Option<PrefixOp> { self.op().map(|(_, kind)| kind) }
    pub fn expr(&self) -> Option<Expr> { support::child(AstNode::syntax(self)) }
}
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum PrefixOp {
    Plus,
    Minus,
    BitNot,
    Not,
    TypeOf,
}
impl PrefixOp {
    pub fn sign_text(&self) -> &'static str {
        match self {
            PrefixOp::Plus => "+",
            PrefixOp::Minus => "-",
            PrefixOp::BitNot => "~",
            PrefixOp::Not => "not",
            PrefixOp::TypeOf => "typeof",
        }
    }
}
impl fmt::Display for PrefixExpr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct TableExpr(SyntaxNode);
impl AstNode for TableExpr {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::TABLE_EXPR
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl TableExpr {
    pub fn open_brace_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::OPEN_BRACE)
    }
    pub fn fields(&self) -> Option<TableField> { support::child(AstNode::syntax(self)) }
    pub fn close_brace_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::CLOSE_BRACE)
    }
}
impl fmt::Display for TableExpr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct ArgList(SyntaxNode);
impl AstNode for ArgList {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::ARG_LIST
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl ArgList {
    pub fn open_paren_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::OPEN_PAREN)
    }
    pub fn args(&self) -> Option<Expr> { support::child(AstNode::syntax(self)) }
    pub fn close_paren_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::CLOSE_PAREN)
    }
}
impl fmt::Display for ArgList {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct ElifBranch(SyntaxNode);
impl AstNode for ElifBranch {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::ELIF_BRANCH
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl ElifBranch {
    pub fn elif_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::ELIF_KW)
    }
    pub fn condition(&self) -> Option<Expr> { support::child(AstNode::syntax(self)) }
    pub fn then_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::THEN_KW)
    }
    pub fn statements(&self) -> AstChildren<Stmt> { support::children(AstNode::syntax(self)) }
}
impl fmt::Display for ElifBranch {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct ElseBranch(SyntaxNode);
impl AstNode for ElseBranch {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::ELSE_BRANCH
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl ElseBranch {
    pub fn else_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::ELSE_KW)
    }
    pub fn statements(&self) -> AstChildren<Stmt> { support::children(AstNode::syntax(self)) }
}
impl fmt::Display for ElseBranch {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct TableField(SyntaxNode);
impl AstNode for TableField {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::TABLE_FIELD
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl TableField {
    pub fn name(&self) -> Option<TableFieldName> { support::child(AstNode::syntax(self)) }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::EQ)
    }
    pub fn expr(&self) -> Option<Expr> { support::child(AstNode::syntax(self)) }
}
impl fmt::Display for TableField {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub enum TableFieldName {
    Name(Name),
    TableFieldNameExpr(TableFieldNameExpr),
}
impl AstNode for TableFieldName {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        <Name as AstNode>::can_cast(kind) || <TableFieldNameExpr as AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        let kind = node.kind();
        if <Name as AstNode>::can_cast(kind) {
            let casted = <Name as AstNode>::cast(node).expect("Invalid `can_cast` implementation");
            return Some(Self::Name(casted));
        }
        if <TableFieldNameExpr as AstNode>::can_cast(kind) {
            let casted = <TableFieldNameExpr as AstNode>::cast(node)
                .expect("Invalid `can_cast` implementation");
            return Some(Self::TableFieldNameExpr(casted));
        }
        None
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> {
        match self {
            Self::Name(x) => x.syntax(),
            Self::TableFieldNameExpr(x) => x.syntax(),
        }
    }
}
impl fmt::Display for TableFieldName {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct TableFieldNameExpr(SyntaxNode);
impl AstNode for TableFieldNameExpr {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::TABLE_FIELD_NAME_EXPR
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl TableFieldNameExpr {
    pub fn open_bracket_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::OPEN_BRACKET)
    }
    pub fn expr(&self) -> Option<Expr> { support::child(AstNode::syntax(self)) }
    pub fn close_bracket_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::CLOSE_BRACKET)
    }
}
impl fmt::Display for TableFieldNameExpr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct WildcardPat(SyntaxNode);
impl AstNode for WildcardPat {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::WILDCARD_PAT
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl WildcardPat {
    pub fn underscore_token(&self) -> Option<SyntaxToken> {
        support::token(AstNode::syntax(self), SyntaxKind::UNDERSCORE)
    }
}
impl fmt::Display for WildcardPat {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}

pub struct Param(SyntaxNode);
impl AstNode for Param {
    type Language = LicoLanguage;
    fn can_cast(kind: <Self::Language as rowan::Language>::Kind) -> bool {
        kind == SyntaxKind::PARAM
    }
    fn cast(node: rowan::SyntaxNode<Self::Language>) -> Option<Self> {
        if Self::can_cast(node.kind()) {
            Some(Self(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::SyntaxNode<Self::Language> { &self.0 }
}
impl Param {
    pub fn name(&self) -> Option<Name> { support::child(AstNode::syntax(self)) }
}
impl fmt::Display for Param {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Display::fmt(self.syntax(), f) }
}
