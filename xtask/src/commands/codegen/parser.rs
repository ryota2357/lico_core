use super::{ensure_file_contents, rustfmt};
use crate::{Level, message, project_root};
use anyhow::Result;
use ignore::Walk;
use quote::{format_ident, quote};
use std::{
    collections::HashMap,
    fs,
    path::{Path, PathBuf},
};
use xshell::Shell;

pub(crate) fn generate(sh: &Shell, check: bool) -> Result<()> {
    let src_path = project_root().join("crates/parser/src");
    let data_path = project_root().join("crates/parser/test_data/inline");

    let rust_files = list_files_by_extension(&src_path, "rs")?;
    let tests = {
        let mut tests = Vec::new();
        for file in rust_files {
            let text = fs::read_to_string(&file)?;
            tests.extend(extract_test(&text));
        }
        tests
    };

    // Remove old tests
    let mut exist_tests = list_files_by_extension(&data_path, "lico")?
        .into_iter()
        .map(|path| (path.file_stem().unwrap().to_str().unwrap().to_owned(), path))
        .collect::<HashMap<_, _>>();
    for test in &tests {
        exist_tests.remove(&test.name);
    }
    for (_, path) in exist_tests {
        message(Level::Warn, format!("removing {:?}", path.display()));
        fs::remove_file(path)?;
    }

    for test in &tests {
        ensure_file_contents(
            &project_root()
                .join("crates/parser/test_data/inline")
                .join(format!("{}.lico", test.name)),
            &test.code,
            check,
        )?;
    }
    ensure_file_contents(
        &project_root().join("crates/parser/tests/inline.rs"),
        &{
            let header = [
                "//! This file is generated by `cargo codegen parser`, do not edit by hand.",
                "#![cfg_attr(rustfmt, rustfmt::skip)]",
                "",
                "mod utils;",
                "const GROUP: &str = \"inline\";",
                "",
            ]
            .join("\n");
            let code = {
                let name_idents = tests.iter().map(|test| format_ident!("{}", test.name));
                let name_strs = tests.iter().map(|test| test.name.as_str());
                let paths =
                    tests.iter().map(|test| format!("../test_data/inline/{}.lico", test.name));
                quote! {
                    #(
                        #[test]
                        fn #name_idents() {
                            let source = include_str!(#paths);
                            let snapshot = utils::make_snapshot(#name_strs, source);
                            utils::assert_snapshot!(GROUP, snapshot);
                        }
                    )*
                }
            };
            format!("{}\n{}", header, rustfmt(sh, code.to_string())?)
        },
        check,
    )?;

    Ok(())
}

fn list_files_by_extension(path: &Path, ext: &str) -> Result<Vec<PathBuf>> {
    let mut res = Vec::new();
    for entry in Walk::new(path) {
        let entry = entry?;
        if entry.path().extension() == Some(ext.as_ref()) {
            res.push(entry.path().to_path_buf());
        }
    }
    res.sort();
    Ok(res)
}

struct Test {
    name: String,
    code: String,
}

fn extract_test(text: &str) -> Vec<Test> {
    let mut res = Vec::new();
    let mut name = String::new();
    let mut code = String::new();
    for line in text.lines().map(str::trim_start) {
        let Some(line) = line.strip_prefix("//") else {
            if !name.is_empty() {
                res.push(Test { name: name.clone(), code: code.clone() });
                name.clear();
                code.clear();
            }
            continue;
        };
        let line = line.strip_prefix(' ').unwrap_or(line);
        match line.strip_prefix(":test") {
            Some(next_name) => {
                if !name.is_empty() {
                    res.push(Test { name: name.clone(), code: code.clone() });
                    code.clear();
                }
                name = next_name.trim().to_string();
            }
            _ if !name.is_empty() => {
                if !code.is_empty() {
                    code.push('\n');
                }
                code.push_str(line);
            }
            _ => {}
        }
    }
    res
}
